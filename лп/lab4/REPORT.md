#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Обыденкова Ю.Ю.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|      13/12        |      4         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Естественный язык – очень сложная система с неочевидной и гибкой структурой. Любой анализ естественного языка сводиться к нескольким этапам: предварительный анализ (поиск границ слов и предложений), морфологический анализ (установление словарных форм слов и приписывание им морфологических признаков), синтаксический анализ (зависимости между словами), семантический анализ (смысл предложения или отдельных слов). Грамматика описывает закономерности устройства языка, но она имеет описательный характер и, к сожалению, не всегда содержит явные и чёткие правила формирования предложений. Самой главной задачей анализа естественного языка является выявление закономерностей. В этом используется два подхода -- работа эксперта-лингвиста и автоматическое исследование размеченных данных.

В данной работе будет использоватся первый подход, будет исследована ограниченная часть языка, и в ней выделены правила грамматики. Грамматика в таком случае будет характеризоватся двумя множествами - терминальными и нетерминальными элементами, а также правилами перехода, которые будут учитывать контекст.

Пролог удобен для таких задач, т.к. на нём удобно описывать грамматику, она понятна человеку, который читает код, и в то же время человеку, который его пишет.

## Задание

8. Реализовать преобразователь активных и пассивных форм типа:
[’Саша’, ’и’, ’Лена’, ’любят’, ‘шоколад’] и
[’шоколад’, ’любим’, ’Сашей’, ’и’, ’Петей’]
в глубинные структуры типа и сравнить полученные глубинные структуры.
```Prolog
Запрос: ?- compare([’Саша’, ’и’, ’Лена’, ’любят’, ‘шоколад’] ,
[’шоколад’, ’любим’, ’Сашей’, ’и’, ’Леной’], Ph1, Ph2, Y).
Результат: Ph1=likes([agent(’Саша’), agent(’Лена’)], object(’шоколад’)),
Ph2=likes([agent(’Саша’), agent(’Лена’)], object(’шоколад’)), Y=yes.
```
## Принцип решения

Глубинная форма - форма содержащая в себе только смысл части предложения, без морфологических признаков, не требующая пояснения форм слов.

Активная и пассивная формы отличаются тем как действие связывает субъект и объект . Пример активной формы: Саша любит шоколад, пассивной: шоколад любим Сашей. Прекрасно видно чем они отличаются: глагол стоит в активном или пассивном залоге, и падежи существительных отличаются. Эти закономерности и лежат в основе программы.

Поскольку структура программы довольно сложна, сперва поясню как производится разбор одной фразы, и лишь в самом конце перейду к полноценной задаче.

`a_phrase(P, zalog(_), L)` анализ фраз в различных формах
```prolog
% активный залог
a_phrase(P, zalog('актив'), L):-
  append([X|XT], [Y|Z], L),
  glag(X2, zalog('актив'), Y),
  compose_agent(X1, pad('именит'), [X|XT]),
  compose_agent(X3, pad('винит'), Z),
  P = [X2, X1 ,X3].

% пассивный залог
a_phrase(P, zalog('пассив'),L):-
  append([X|XT], [Y|Z], L),
  glag(X2, zalog('пассив'), Y),
  compose_agent(X1, pad('именит'), [X|XT]),
  compose_agent(X3, pad('творит'), Z),
  P = [X2, X3 ,X1].
```  
Фраза задается списком L который разбивается на три части: глагол, объект, субъект (все они непустые).

`compose_agent(Answer, zalog(_), Text)` составление группы существительных (возможно соединенных союзом и)
```prolog
% несколько существтельных соединенных союзом
compose_agent([X|Ans], K,[H,Y|T]):-
  agent(X, K, H),
  union(Y),
  compose_agent(Ans, K, T).
% одно существительное
compose_agent([X], K,[H]):-
  agent(X, K, H).
```  
Из фразы формируется список с существительными в глубинной форме (союз в список не входит).

`agent(XC, K, X)` Получение глубинной формы существительного

`glag(XC, K, X)` Получение глубинной формы глагола
```prolog
% предикат существительного
agent(XC, K, X):-
  gen_mest(File_mest),
  fid(X, XC, K, File_mest).

% предикат глагола
glag(XC, K, X):-
  gen_glag(File_glag),
  fid(X, XC, K, File_glag).
```
Генерируется словарь и вызывается функция поиска слова в словаре

`fid(Word, Ans, Form, File)` Поиск слова по всему словарю

`condition(Word, Ans, Form, Ans:Form:List)` Поиск и выделение глубинной формы слова по конкретной строке в словаре
```prolog
% поиск словоформы в словаре
fid(X, XC, K, File):-
  member(M, File),
  condition(X, XC, K, M).

condition(X, XC, K, XC:K:L):-
  member(X, L).
```  
Выделяется строчка словаря и для неё вызывается `condition` для выделения глубинной формы из формы `K`

Подробнее о структуре словаря:
Для структуры словаря зарезервирован оператор `op(200, xfy, ':').` Запись в словаре имеет вид:
```prolog
"Глубинная форма' : форма слова : [Список вариаций слова в этой форме]
% Например
'Маша':pad('творит'):['Машей']
'любить':zalog('пассив'):['любим', 'любима', 'любимо', 'любимы']
```
Главная процедура `compare()` - построение глубинных структур фраз и их сравнение
```prolog
% сравнение на естественном языке
% (Фраза1, Фраза2, Гл.Структура1, Гл.Структура2, Равны?)
compare(X,Y,Ph1,Ph2,Eq):-
  % выделение структуры фраз
  a_phrase(Ph1,_,X),
  a_phrase(Ph2,_,Y),
  Ph1 = [A, Obj1, Subj1],
  Ph2 = [B, Obj2, Subj2],
  % сортировка списков объектов и субъектов
  % чтобы фразы с различным их порядком следования были равными
  sort(Obj1,S1),
  sort(Subj1, S2),
  sort(Obj2, S3),
  sort(Subj2, S4),
  % сравнение
  cmp([A,S1,S2],[B,S3,S4],Eq).

% сравнение
%(Объект 1, Объект2, yes/no)
cmp(X,Y,Ans):-
  X = Y,
  Ans = 'yes', !.
cmp(_,_,'no').
```
В ней происходит вызов анализатора фразы для заданных фраз, затем их списки объектов и субъектов сортируются (чтобы фразы с различным их порядком следования были равными), выполняется определение их идентичности.

## Результаты
```prolog
?- compare(['Саша', 'и', 'Лена', 'любят', 'шоколад'] , ['шоколад', 'любим','Сашей', 'и', 'Леной'], Ph1,Ph2, Y).
Ph1 = Ph2, Ph2 = [likes, ['Саша', 'Лена'], [шоколад]],
Y = yes.

?- compare(['Юля', 'и', 'Глеб', 'любят', 'сосиски'] , ['сосиски', 'любимы','Глебом', 'и', 'Юлей'], Ph1,Ph2, Y).
Ph1 = [likes, ['Юля', 'Глеб'], [сосиски]],
Ph2 = [likes, ['Глеб', 'Юля'], [сосиски]],
Y = yes.

?- compare(['Саша','и','Юля', 'обожают', 'еду','и','деньги'],['деньги','и','еда','обожаемы','Юлей','и','Сашей'],Ph1,Ph2,Y).
Ph1 = [likes, ['Саша', 'Юля'], [еда, деньги]],
Ph2 = [likes, ['Юля', 'Саша'], [деньги, еда]],
Y = yes.

?- compare(['Юля', 'и', 'Глеб', 'любят', 'сосиски'] , ['сосиски', 'любимы','Глебом'], Ph1,Ph2, Y). 
Ph1 = [likes, ['Юля', 'Глеб'], [сосиски]],
Ph2 = [likes, ['Глеб'], [сосиски]],
Y = no.
```
## Выводы

Проделав лабораторную работу, я составила несложный фрагмент естественного-языкового интерфейса к модельной задаче. Мною была реализована грамматика для небольшой части русского языка: активной и пассивной формах. Я составила грамматические правила для этой части и вынесла слова в словарь. Таким образом можно подключать словари и выполнять программу для различных слов.

Пролог был удобен для решения задач грамматического разбора: реализация правил перехода довольно очевидна и проста.
