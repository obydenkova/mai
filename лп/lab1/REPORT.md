# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Обыденкова Ю.Ю.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|     12/12         |      3         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Любой список в Прологе можно представить как двоичное дерево, в листьях которого находятся элементы списка или пустой список. Элементами списка могут быть любые объекты. То есть он либо пуст, либо состоит из 2х частей: головы и хвоста, который сам является списком.

То, что называется списком в императивных языках, сильно отличается от списка в Прологе. Не во всех императивных языках есть такая структура данных, как список. Обрабатывать элементы списка в Прологе можно только рекурсивно, разделяя список на голову и хвост. В императивных языках, чтобы обратиться к какому-то элементу списка, мы можем использовать итераторы. Список в императивном языке может содержать в себе только элементы одинакового типа, в Прологе списки содержат любые элементы. Логичнее было бы сравнить списки в Прологе с массивами, т.к. и те, и другие чаще других типов используются в программах. Но к элементам массива мы имеем произвольный доступ, чего не скажешь о списках.

## Задание 1.1: Предикат обработки списка
Циклический сдвиг списка вправо на n элементов
`rSlide(L,N,S).` - с использованием встроенных предикатов
`rSlider(N, L0, L3).` - без использования встроенных предикатов
Примеры использования:
1) с использованием встроенных предикатов
```prolog
?- rSlide([1,2,3,4,5,6,7],3,X).
X = [5, 6, 7, 1, 2, 3, 4].

?- rSlide([1,2,3,4,5,6,7],7,X).
X = [1, 2, 3, 4, 5, 6, 7].
```
2) без использования встроенных предикатов
```Prolog
?- rSlider([10,20,30,40,50,60],4,X).
X = [30, 40, 50, 60, 10, 20].

?- rSlider([10,20,30,40,50,60],2,X).
X = [50, 60, 10, 20, 30, 40].
```
Реализация:
Без встроенных предикатов. Использую для реализации два предиката `appendList()`, с помощью которого объединяем списки и `lengthList()`, который пределяет длину списка. Исходный список разделяется на левую и правую части. Для той части, которая будет перемещаться  — длина списка должна быть равна N. На этом месте работает перебор с возвратами prolog-а, в результате которого первые два шага алгоритма будут повторяться до тех пор, пока списки не будут разделены так, что размер перемещаемой части будет равен N. Левая и правая части соединяются «задом наперед», т.е. справа ставится левая, а слева — правая.
Для случая когда N > length(List) необходимо сдвиг выполнять на N mod Len позиций.

```prolog
rSlider(N, L0, L3) :-
    appendList(L1, L2, N),
    lengthList(L2, L0),
    appendList(L2, L1, L3), !.
```
С использованием встроенных предикатов. Также использую уже встроенные предикаты `append` и `length`, которые работают аналогично выше описанным.

    rSlide(L,N,S) :-
    append(Left,Right,L),
    length(Right,N),
    append(Right,Left,S), !.

## Задание 1.2: Предикат обработки числового списка

Вычисление минимального элемента
`min_list(X,Y).` - с использованием встроенных предикатов
`minList(A,B).` - без использования встроенных предикатов
Примеры использования:
1) с использованием встроенных предикатов
```prolog
?- min_list([1,23,4,5,2,-53,6],X).
X = -53.

?- min_list([0,12,43,64,-9,-13,98,-1],X).
X = -13.
```
2) без использования встроенных предикатов
```Prolog
?- minList([0,1,2,3,4,-1,-2,-3,12],X).
X = -3.

?- minList([100,90,200,143],X).
X = 90.
```
Реализация:
С использованием встроенных предикатов. Найти минимальный элемент в списке можно при
помощи рекурсивного предиката и min_list, который ищет минимальный элемент в списке на
обратном ходе рекурсии, начиная с последнего элемента, при этом `MinElem` является текущим минимумом и результатом одновременно. 

   ```Prolog
  min_list([MinElem], MinElem):-!.
  min_list([Head|Tail], MinElem):-
    min_list(Tail, TailMinElem),
    TailMinElem < Head, !, MinElem = TailMinElem;
    MinElem = Head.  
```
Без встроенных предикатов. Предикат `minList()` работает так же, как и вышеописанный предикат `min_list()`

```prolog
 minList([Head|Tail],Result):-
    minList(Tail,Result),Result<Head,!.
    minList([Head|_],Head).
```

## Задание 2: Реляционное представление данных

Достоинство реляционного представления данных студентов, которое я использовалa, в том, что доступ к информации о группе и списку оценок за все предметы не представляет особых затруднений, то есть может быть осуществлен за O(1). В то же время поиск оценок в данном списке со стороны сдаваемого предмета, а не студента, вызывает ряд затруднений - приходится проходить весь список целиком.

`exms(X)` - предикат истинен, если студент сдал все экзамены(нет ни одной 'двойки'), и ложен, если студент не сдал хотя бы один экзамен. Рекурсивно просматривается список оценок студента по всем предметам. Если за экзамен оценка 2, то предикат ложен, иначе истинен.
Реализация:
```prolog
exms(Stud):-
	student(_,Stud,Marks),
	not(member(grade(_,2),Marks)).
```

`sredn(X,Y)`-  X - фамилия студента, Y - средняя оценка студента по всем предметам.

Рекурсивно просматриваются оценки студента по всем предметам, они суммируются, а потом полученное число делится на количество предметов.
Реализация:
```Prolog
sredn(Stud,Mark):-
	student(_,Stud,Q),
	sum(Q, Sum),
	length(Q,Len),
	Mark is Sum / Len.
% сумма всех элементов в списке
% (список, сумма)
sum([grade(_, H)|T],N):-
	sum(T,K),
	N is K+H.
  sum([],0).
```

`sfailed(X, Y)` - Y - количество студентов, не сдавших предмет X(получивших оценку 2). Создается список, содержащий списки из оценок всех студентов по всем предметам. Рекурсивно проверяется, содержится ли в голове списка предмет, по которому получена оценка 2 - если содержится, то Y увеличивается на 1, если нет, то просматривается хвост "общего" списка.
Реализация:
```Prolog
sfailed(Subj,N):-
	subject(Ss,Subj),
	findall(A,(student(_,_,A),gradeInList(A,Ss)),AllMarks),
	length(AllMarks,N).

gradeInList([grade(Subj,2)|_],Subj).
gradeInList([_|Tail],Subj):-
	gradeInList(Tail,Subj).
```
`thebest(X, Y)` - в группе X ищутся студенты, имеющие максимальный средний балл в ней. Y - список фамилий этих студентов. Ищется максимальный средний балл в данной группе, после чего ищутся студенты этой группы, имеющие такой средний балл.
Реализация:
```Prolog
thebest(Group,N):-
 % список со всеми средними оценками
 findall(Mark, (student(Group,Stud,_), sredn(Stud,Mark)),Marks),
 % максимальная оценка
 max(Marks,Max),
 % список студентов с максимальной оценкой
 findall(A,(student(Group,A,_), sredn(A,M), M==Max), N),!.
  
% нахождение максимального из положительного числового списка
% (список, максимум)
max([],0).
max([H|T],N):-
  max(T,R),
  H =< R,
  N is R.
max([H|T],N):-
  max(T,R),
  H >= R,
  N is H.
```
Примеры использования:
```prolog
?- sredn('Петров',X).
X = 4. % средняя оценка Петрова по всем предметам

?- sredn('Эфиркина',X).
X = 3.8333333333333335. % средняя оценка Эфиркиной по всем предметам

?- exms('Шарпин').
false. % Шарпин что-то не сдал

?- exms('Фулл').
true. % Фулл сдал все экзамены

?- sfailed('Логическое программирование',X).
X = 0. % Логическое программирование сдали все студенты

?- sfailed('Информатика',X).
X = 3. % Информатику не сдало 3 студента

?- thebest(103,X).
X = ['Вебсервисов'].  % Вебсервисов лучший в группе 103

?- thebest(102,X).
X = ['Азурин']. % Азурин лучший в группе 102
```
## Выводы

В императивных языках мы указываем как что-либо сделать, в Прологе - что необходимо сделать. Мы сообщаем системе, что нам известно и задаем вопросы. Программы на Прологе выглядят простыми, но за ними скрывается мощный логический бэкграунд. Неудивительно, что такое программирование называется логическим, ведь оно помогает найти нетривиальное решение какой-то обыденной задачи. Начинаешь думать о программе как о наборе целей, тем самым разбивая большую задачу на множество простых. Думаю, чтобы понять концепции логического программирования нужно больше практики. Когда сталкиваешься с каким-то принципиально новым для себя явлением, сложно сразу осмыслить его фундаментальные начала. Мне кажется, легче сначала узнать на интуитивном уровне, как это работает, а потом приложить свой опыт к более глубокому изучению. Хорошо, что в этой работе у нас была возможность на простых задачах в первом приближении узнать о логическом программировании и о Прологе в частности.
