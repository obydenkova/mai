#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Обыденкова Ю. Ю.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|      13/12        |        4       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Какие задачи удобным образом решаются методом поиска в пространстве состояний? Почему Prolog оказывается удобным языком для решения таких задач?

Пространство состояний представляет собой набор ситуаций. Из каждого состояния возможно перейти в другое состояние путем каких-то действий. Поэтому удобно использовать такой метод, когда у нас есть два заданных состояния - начальное и конечное, и число всевозможных состояний конечно. Если представить такое пространство как граф, где вершинами являются состояния, то путь от начальной вершины до конечной будет показывать набор состояний, являющийся решением задачи. В итоге, такие задачи сводятся к задаче поиска в графе. Основные стратегии решения такой задачи, которые я использовала в своей работе, - поиск в глубину, поиск в ширину и поиск с итеративным погружением.

Для представления графа в программировании обычно используют матричное представление, где граф задается своей матрицей смежности. В Прологе граф описывается предикатами путем явного перечисления всех дуг в виде пар вершин. Задание графа при помощи дуг является более гибким, чем матрица смежности, поскольку дуги могут задаваться не только явным перечислением, но и при помощи правил, что позволяет нам описывать очень сложные и большие графы, для которых матричное представление нерационально и вообще не всегда возможно.

## Задание

3. Железнодорожный сортировочный узел устроен так, как показано на
рисунке. На левой стороне собрано некоторое число вагонов двух типов
(черные и белые), обоих типов по n штук., в произвольном порядке
Тупик вмещает все 2n вагонов. Пользуясь тремя сортировочными
операциями (слева в тупик, из тупика направо, слева направо, минуя
тупик), собрать вагоны на правой стороне, так, чтобы типы чередовались.
Для решения задачи достаточно 3n-1 сортировочных операций.

## Принцип решения

Я использовала 3 алгоритма поиска: поиск в глубину, поиск в ширину и поиск с итеративным погружением. Они отражены в предикатах search_dpth, search_bdth и search_id соответсвенно.
Рассмотрим часть, общую для всех трех алгоритмов. Предикат prolong() нужен для продления всех путей в графе, предотвращая зацикливания.
```Prolog
prolong(Zabrat,Zabrat1,[H|T],[Y,H|T]):-
    move(Zabrat,H,Zabrat1,Y),
    \+ member(Y,[H|T]).
```
Предикат search_dpth() ищет ответ на задачу, а точнее путь от начального состояния к конечному, с помощью обхода в глубину. В данном случае обход в глубину работает, пока возможно продление пути и не достигнута конечная вершина. Так как путь записан в обратном порядке, его необходимо реверсировать (Данное утверждение справедливо и для остальных алгоритмов). Найденный путь будет необязательно кратчайшим.
```Prolog
search_dpth(A,B):-
    write('DFS START'), nl,
    get_time(DFS),
    dpth([[]],B,L,[],A),
    inv_print(L),
    get_time(DFS1),
    write('DFS END'), nl, nl,
    T1 is DFS1 - DFS,
    write('TIME IS '), write(T1), nl, nl.
```
search_bdth() реализует решение с помощью поиска в ширину. Для него используется очередь из путей, которые можно продлить. Продленные пути добавляются в конец очереди, а путь, который мы продлевали удаляется. Если первый элемент очереди - это путь который ведет в конечную вершину, поиск можно завершить. Найденный путь гарантированно будет кратчайшим.
```Prolog
search_bdth(X,Y):-
    write('BFS START'), nl,
    get_time(BFS),
    bdth([[[]]],X,[],Y,L),
    inv_print(L),
    get_time(BFS1),
    write('BFS END'), nl, nl,
    T1 is BFS1 - BFS,
    write('TIME IS '), write(T1), nl, nl.
```
Поиск с итеративным углублением использует идею метода поиска в глубину, однако глубина поиска ограничивается некоторым значением, поэтому мы ограничываем длину возможных решений, что позволяет найти кратчайший путь.
```Prolog
search_id(Start,Finish):-
    write('ITER START'), nl,
    get_time(ITER),
    int(DepthLimit),
    depth_id([[]],Start,[],Finish,Res,DepthLimit),
    inv_print(Res),
    get_time(ITER1),
    write('ITER END'), nl, nl,
    T1 is ITER1 - ITER,
    write('TIME IS '), write(T1), nl, nl.
```
## Результаты

Результаты работы

```prolog
?- search_dpth(Start,[Way]).
DFS START
[]
[_386]
DFS END

TIME IS 1.9073486328125e-5

Start = [Way|_662] .

?- search_bdth(Start,[Way]).
BFS START
[]
[_386]
BFS END

TIME IS 4.410743713378906e-5

Start = [Way|_668] .

?- search_id(Start,Way).
ITER START
[]
[_648]
ITER END

TIME IS 7.486343383789062e-5

Start = Way, Way = [_648] .
```

Так как в данной задаче граф из состояний содержит всего 3 вершины и 3 дуги, то работа алгоритмов почти идентична. Если бы не существовало условий для передвижений поезда, то есть они двигались как хотели, то поиск выполнялся бы за большее время. С целью уменьшить время поиска эти условия и были добавлены.

## Выводы

В ходе лабораторной работы была успешно выполнена поставленная цель изучен метод поиска в пространстве состояний для решения задачи. Были реализованы три алгоритма поиска в графах: в ширину, глубину и с итеративным углублением.

Из результата работы программы мы видим, что самым быстрым является DFS, однако он нашел не кратчайший путь, и этот путь намного длинее. Я считаю, что поиск и итеративным углублением является наиболее подходящим для решения данной задачи, по следующим причинам:

В отличии от DFS, он находит кратчайший путь для решения, хоть и работает дольше.
Использование BFS оперативной памяти желает оставлять лучшего.

