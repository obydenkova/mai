# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Обыденкова Ю. Ю.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта я получила следующие навыки и знания:

1. Смогла составить и обработать данные в формате GEDCOM. Если в будущем мне понадобится обрабатывать генеалогические деревья, то мне не придется разбираться с их структурой хранения.

2. Познакомилась с языком функционального программирования prolog, а также написала парсер, обрабатывающий файл в формате GEDCOM.

3. Закрепила навыки, связанные с поиском в пространстве состояний. Мне они пригодились для реализации поиска в ширину, который, в свою очередь, был использован для получения цепочки родства.

4. Закрепила навыки, связанные с грамматическим разбором предложения.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: с использованием предикатов parents(потомок, отец, мать).
 3. Реализовать предикат проверки/поиска двоюродного брата.
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Мое родословное дерево было создано при помощи сервиса MyHeritage.com, в нем был 21 человек. Затем я экспортировала это дерево, с помощью встроенных в сервис функций, и получила файл в формате GEDCOM. 

## Конвертация родословного дерева

Для парсинга файла формата GEDCOM я использую язык python. В цикле я пробегаю все строки открытого файла для чтения. Запоминаю в словарь всех родственников, вместе с их ID. Данные помещаются в файл формата pl, использованный для записи.
``` Python
for line in kek.readlines():
    words = line.split(" ")
if r1 == "GIVN":
            name = words[2]
            
        if r1 == "SURN":
            surn = words[2]
            value = (name[:-1], surn[:-1])
            newElem = {key:value}
            base.update(newElem)
```

## Предикат поиска родственника
Согласно варианту, мне нужно реализовать предикат по поиску двоюродного брата.
Для этого необходимо реализовать промежуточный предикат по поиску ребенка. А также я реализовала предикаты male() и и female(), чтобы определять пол ребенка, т.к. предыдущее заданее включало в себя реализацию только одного предиката parents(), из которого невозможно определить именно двоюродного брата, а не сестру.
``` Prolog
child(X, Y) :- 
    parents(X, Z, Y);
    parents(X, Y, Z).
 ```
В предикате child() находится ребенок, если такой существует, и его родители. В предикате cousin() проверяется промежуточное родство между родителями и male() отслеживает, чтобы ребенок был мужского пола. Сам предикат cousin() выглядит следующим образом:
``` Prolog
cousin(Person,X) :- % двоюродный брат
    child(Person,P), child(P,PP), 
    child(Y,PP), child(X,Y),
    Y\=P, male(X).
  ```
Если бы я не добавила предикаты по определению пола, можно было бы реализовать поиск двоюродного брата или сестры следующим образом:

Для этого потребовалось создать предикат bro_or_sist():

``` Prolog
bro_or_sist(X, Y) :- % брат или сестра
    parents(X, F, M),
    parents(Y, F, M),
    X\=Y.
 ```
А затем реализовать сам предикат поиска двоюродной связи:

``` Prolog
double(X, Y) :- % двоюродные брат или сестра
    parents(X, F1, M1),
    parents(Y, F2, M2),
    X\=Y,
    
    (bro_or_sist(F1, F2);
    bro_or_sist(F1, M2);
    bro_or_sist(M1, F2);
    bro_or_sist(M1, M2)).
```
## Определение степени родства

Далее реализую предикаты отношений relative(). Стандартные отношения отец, мать, ребенок и т.д.
После них, если не будет найдено обычных отношений, с помощью поиска в глубину будем выводить путь от одного родственника до другого.
``` Prolog
relative(child, Child, Parent) :-
    parents(Child, _, Parent);
    parents(Child, Parent, _).
   
relative(father, Father, Child) :-
    parents(Child, Father, _).

relative(mother, Mother, Child) :-
    parents(Child, _, Mother).

relative(husband, Husband, Wife) :-
    parents(_, Husband, Wife), !.
 
 % цепочка родства
 
relative(Way, First, Last) :-
    dpath(First, Last, Way), !.   
  
```
Затем, используя поиск в ширину, находим кратчайшее отношение родства. После этого мы находим "цепочку" родственников, по которой и связаны эти люди, а затем переводим ее в цепочку родства, получая ответ.

Результат работы предиката:
```Prolog
?- relative(X, 'Юлия Обыденкова','Виктория Обыденкова').
X = sister .
?- relative(mother,X, 'Юлия Обыденкова').
X = 'Наталья Харина'.
?- relative(Way,'Евгений Никифоров','Наталья Харина').
child - child - wife - father - 
Way = [father, wife, child, child].
?- relative(Way,'Евгений Никифоров','Юлия Обыденкова').
Way = double ;
child - child - wife - father - wife - father - 
Way = [father, wife, father, wife, child, child].
```
## Естественно-языковый интерфейс

На основе входных данных проверям верность высказывания, если оно корректно находится результат. В качестве входных данных мы принимаем список из слов на естественном языке. Каждый элемент списка имеет свое назначение, к примеру, start_of_question() отвечает за начальное слово (who) и т.д. 
Пример:
```Prolog
ask_the_question(List):-
      List = [Word, Is, Name, Suff, Relation, Qstn],
      start_of_question(Word),
      is(Is),
      (male(Name);
      female(Name)),
      nb_setval(lastName, N),
      suffix(Suff),
      chain_of_relation(Relation),
      mark_of_question(Qstn), !,
      relative(Relation, Res, Name),
      write(Res), write(" is "), write(Name), write("'s "), write(Relation).
```

Главный предикат ask_the_question() принимает на вход вопросительное предложение в виде списка и, если оно корректно, выводит результат. Корректность проверяется наличием всех слов, необходимых для того чтобы задать вопрос.

Результат работы:
```Prolog
?- ask_the_question([who, is, 'Юрий Обыденков', "'s", mother,?]).
Раиса Новикова is Юрий Обыденков's mother
true.

?- ask_the_question([who,is,'Юлия Обыденкова',"'s",sister,?]).
Виктория Обыденкова is Юлия Обыденкова's sister
true 

?- ask_the_question([is,'Юлия Обыденкова','Виктория Обыденкова',"'s",sister,?]).
true.
```
## Выводы

Сначала, когда я еще не была знакома с таким языком логического программирования как Prolog, мне было сложно понять принцип его работы, т.к. все языки с которыми я сталкивалась были компилируемыми, к примеру, Си, С++. Но, выполняя курсовую работу, я начала лучше в нем ориентироваться.
На примере данной работы, мы можем увидеть, что для ее решения лучше всего использовать логический язык программирования. Я увидела большое преимущество его работы с большим обьемом данных. Также я познакомилась с языком программирования Python и  поняла, что этот язык очень простой (особенно для работы со строками) и полезный. В дальнейшем я планирую изучить этот язык глубже и основательнее.
